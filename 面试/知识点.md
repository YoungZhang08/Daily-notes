标准盒模型

 

![img](/media/nvnvyezi/linux_software/linux-web/web-note/面试/3534156-e2309fc21e18ce8d.jpg)

 

ie盒子模型

 

![img](/media/nvnvyezi/linux_software/linux-web/web-note/面试/3534156-55b43078fcef0bec.png)

 

> 在标准模式下，一个块的总宽度=width+margin(左右)+padding(左右)+border(左右)

> 在怪异模式下，一个块的总宽度=width+margin（左右）（既width已经包含了padding和border值）

 

**清除浮动**

 

- `clear` 

- 利用为伪元素

- `overflow`

 

#### input标签

 

1、需要指定type属性，如text，password等。

 

2、通过size属性指定显示字符的长度。

 

3、value属性指定初始值

 

4、Maxlength属性指定文本框可以输入的最长长度。

 

5、焦点垂直居中文本框中，单行

 

#### textarea标签

 

1、需要</textarea>来封闭标签

 

2、内容写在标签对中

 

3、使用row、col指定textarea大小

 

4、焦点在左上角，多行

 

**div模拟textarea**

 

```
<div contenteditable="true"></div>
```

 

**移动设备忽略页面中的数字识别为电话号码**

 

```
<meta name = "format-detection" content = "telephone=no">
```

 

\## Meta标签中的format-detection属性及含义

 

format-detection翻译成中文的意思是“格式检测”，顾名思义，它是用来检测html里的一些格式的，那

 

关于meta的format-detection属性主要是有以下几个设置：<meta name="format-detection" content="telephone=no">



```html
<meta name="format-detection" content="email=no">

<meta name="format-detection" content="adress=no">

<meta name="format-detection" content="telephone=no,email=no,adress=no">
```

 

下面具体说下每个设置的作用：

 

一、telephone

 

你明明写的一串数字没加链接样式，而iPhone会自动把你这个文字加链接样式、并且点击这个数字还会自动拨号！想去掉这个拨号链接该如何操作呢？这时我们的meta又该大显神通了，代码如下：

 

telephone=no就禁止了把数字转化为拨号链接！

telephone=yes就开启了把数字转化为拨号链接，要开启转化功能，这个meta就不用写了,在默认是情况下就是开启！

 

二、email

 

告诉设备不识别邮箱，点击之后不自动发送

 

email=no禁止作为邮箱地址！

email=yes就开启了把文字默认为邮箱地址，这个meta就不用写了,在默认是情况下就是开启！

 

三、adress

 

adress=no禁止跳转至地图！

adress=yes就开启了点击地址直接跳转至地图的功能,在默认是情况下就是开启！

 

**左右布局（左边定宽，右边自适应）**

````html
<div class="left">left</div>
<div class="right">eight</div>
````

```css
.left {

  width: 200px;

  height: 100%;

  background: red;

  float: left;

}

.right {

  width: calc(100% - 200px);

  height: 100%;

  background: yellow;

  float: left;//或者overflow:hidden;

}
```



 

```css
body {  
  display: flex;

  justify-content: space-around;

}

.left {

  width: 200px;

  height: 100%;

  background: red;

}

.right {

  width: calc(100% - 200px);//或者flex:1 1 auto;

  height: 100%;

  background: yellow;

}
```

 



```css
.left {
	width: 200px;

  height: 100%;

  background: red;

  position: absolute;

  left: 0;

}

.right {

  position: absolute;

  left: 200px;

  width: calc(100% - 200px);

  height: 100%;

  background: yellow;

}
```

 

1. 双`inline-block`

2. 双float

3. float+margin-left

4. absolute+margin-left

5. float+bfc

6. flex

7. grid

 

**三栏布局**

 

```html
<div class="left"></div>
 <div class="right"></div>
  <div class="main"></div>
```



```css
 div {
 height: 100px;

}

.left{

  width: 100px;

  background: red;

  float: left;

}

.main{

  /* width: calc(100% - 200px); */

  background: green;

  margin-left: 100px;

  margin-right: 100px;

}

.right {

  width: 100px;

  background: yellow;

  float: right;

} 
```





```css
div {
height: 100px;

}

.left{

  width: 100px;

  background: red;

  /* float: left; */

  position: absolute;

  left: 0;

}

.main{

  /* width: calc(100% - 200px); */

  background: green;

  margin-left: 100px;

  margin-right: 100px;

}

.right {

  width: 100px;

  background: yellow;

  /* float: right; */

  position: absolute;

  right: 0;

}
```

 

圣杯布局

````
<div class="container">
    <div class="main">middle</div>
        <div class="left">left</div>
            <div class="right">right</div> 
            </div>
````

 



```css
div {
height: 100px;

}

.container {

  padding: 0 100px;

}

.left{

  width: 100px;

  background: red;

  float: left;

  margin-left: -100%;

  position: relative;

  left: -100px;

}

.main{

  width: 100%;

  background: green;

  float: left;

}

.right {

  float: left;

  width: 100px;

  background: yellow;

  margin-left: -100px;

  position: relative;

  left: 100px;

}
```

双飞燕

 

````
<div class="container">
    <div class="main">
          <div class="in">middle</div>
     </div>
     <div class="left">left</div>
    <div class="right">right</div>
</div>
````



```css

div {
height: 100px;

}

.left{

  width: 100px;

  background: red;

  float: left;

  margin-left: -100%;

}

.main{

  width: 100%;

  background: green;

  float: left;

}

.right {

  float: left;

  width: 100px;

  background: yellow;

  margin-left: -100px;

}

.in {

  margin: 0 100px;

}
```

 

```
<div class="container">    
    <div class="left">left</div>
    <div class="main">middle</div>\
    <div class="right">right</div>  
</div>
```





```css
div {  
  height: 100px;

}

.container {

  display: flex;

  justify-content: space-around;

}

.left{

  width: 100px;

  background: red;

}

.main{

  width: 100%;

  background: green;

  flex: 1 1 auto;

}

.right {

  width: 100px;

  background: yellow;

}
```

\```

 

**css3新特性**

 

https://juejin.im/entry/595f1e3c5188250d914dd53c

 

**BFC**快级格式上下文



> 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。
>

 

触发条件

 

- float值不为none

- position不为relative和static

- display的值是inline-block、table-cell、flex、table-caption或者inline-flex

- overflow值不为visible

 

BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。

 

**外边距折叠**

 

1、两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。

2、两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。

3、两个外边距一正一负时，折叠结果是两者的相加的和。

 

原因：

 

> 	在CSS中，两个或多个毗邻的普通流中的盒子（可能是父子元素，也可能是兄弟元素）在垂直方向上的外边距会发生叠加，这种形成的外边距称之为外边距叠加。

>

> ### 毗邻

>

> 毗邻说明了他们的位置关系，没有被 `padding`、`border`、`clear` 和 `line box` 分隔开。

>

> ### 两个或多个

>

> 两个或多个盒子是指元素之间的相互影响，单个元素不会存在外边距叠加的情况。

>

> ### 垂直方向

>

> > Horizontal margins never collapse.

>

> 只有垂直方向的外边距会发生外边距叠加。水平方向的外边距不存在叠加的情况。

>

> ### 普通流(in flow)

>

> 啥为普通流？W3C 只对 out of flow 作了定义：

>

> > An element is called out of flow if it is floated, absolutely positioned, or is the root element.An element is called in-flow if it is not out-of-flow.

>

> 从定义中我们可以知道只要不是 `float`、`absolutely positioned` 和 `root element` 时就是 in flow。

 

从定义中我们可以很清楚的知道要符合哪些情况才会发生外边距折叠：

- 都属于普通流的块级盒子且参与到相同的块级格式上下文中

- 没有被padding、border、clear和line box分隔开

- 都属于垂直毗邻盒子边缘：

- 盒子的top margin和它第一个普通流子元素的top margin

- 盒子的bottom margin和它下一个普通流兄弟的top margin

- 盒子的bottom margin和它父元素的bottom margin

- 盒子的top margin和bottom margin，且没有创建一个新的块级格式上下文，且有被计算为0的min-height，被计算为0或auto的height，且没有普通流子元素

 

**解决**：

 

- 浮动元素不会与任何元素发生叠加，也包括它的子元素

- 创建了 BFC 的元素不会和它的子元素发生外边距叠加

- 绝对定位元素和其他任何元素之间不发生外边距叠加，也包括它的子元素

- inline-block 元素和其他任何元素之间不发生外边距叠加，也包括它的子元素

- 普通流中的块级元素的 margin-bottom 永远和它相邻的下一个块级元素的 margin-top 叠加，除非相邻的兄弟元素 clear

- 普通流中的块级元素（没有 border-top、没有 padding-top）的 margin-top 和它的第一个普通流中的子元素（没有clear）发生 margin-top 叠加

- 普通流中的块级元素（height为 auto、min-height为0、没有 border-bottom、没有 padding-bottom）和它的最后一个普通流中的子元素（没有自身发生margin叠加或clear）发生 margin-bottom叠加

- 如果一个元素的 min-height 为0、没有 border、没有padding、高度为0或者auto、不包含子元素，那么它自身的外边距会发生叠加

 

**ＢＦＣ包含浮动**

 

**使用BFC避免文字环绕**
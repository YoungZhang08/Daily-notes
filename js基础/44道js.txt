Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2018-06-15T13:49:56+08:00

====== 44道js ======
创建日期 星期五 15 六月 2018


作者：17点
链接：https://juejin.im/post/5b1f899fe51d4506c60e46ee

===== 1. ["1", "2", "3"].map(parseInt) =====

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image.png)

parseInt (val, radix) ：两个参数，val值，radix基数（就是多少进制转换）
	 map 能传进回调函数 3参数 (element, index, array)

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image002.png)

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image001.png)

__parseInt('1', 0);  //0代表10进制__
__     parseInt('2', 1);  //没有1进制，不合法__
__     parseInt('3', 2);  //2进制根本不会有3__

{{./pasted_image003.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image003.png)

===== 2.[typeof null, null instanceof Object] =====

{{./pasted_image004.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image004.png)

答案：["object", false]
解析：null代表空对象指针，所以typeof判断成一个对象。可以说JS设计上的一个BUG
	 instanceof 实际上判断的是对象上构造函数，null是空当然不可能有构造函数
巩固：null == undefined //true    null === undefined //flase


instanceof运算符用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上

===== 3. [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ] =====

{{./pasted_image006.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image006.png)

如果一个函数不传初始值，数组第一个组默认为初始值.
		 [3,2,1].reduce(Math.pow)
		 Math.pow(3,2) //9
		 Math.pow(9,1) //9
reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。

reduce() 可以作为一个高阶函数，用于函数的 compose。

注意: reduce() 对于空数组是不会执行回调函数的。

{{./pasted_image005.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image005.png)

[].reduce(Math.pow)       //空数组会报TypeError
	 [1].reduce(Math.pow)      //只有初始值就不会执行回调函数，直接返回1
	 [].reduce(Math.pow,1)     //只有初始值就不会执行回调函数，直接返回1
	 [2].reduce(Math.pow,3)    //传入初始值，执行回调函数，返回9
{{./pasted_image007.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image007.png)

===== 4. =====
{{./pasted_image008.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image008.png)

字符串连接比三元运算有更高的优先级 
	 所以原题等价于 'Value is true' ? 'Somthing' : 'Nonthing' 
	 而不是 'Value   is' + (true ? 'Something' : 'Nonthing')

===== 5. =====
{{./pasted_image009.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image009.png)

（1）typeof时 name变量提升。 在函数内部之声明未定义
	 （2）typeof优先级高于===

{{./pasted_image010.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image010.png)Hello World 因为name已经变成函数内局部变量

===== 6. =====
var END = Math.pow(2, 53);
var START = END - 100;
var count = 0;
for (var i = START; i <= END; i++) {
	count++;
}
console.log(count);

它进入一个无限循环，2 ^ 53是javascript中可能的最大数字，2 ^ 53 + 1给出2 ^ 53，因此i永远不会变得比这更大。

===== 7. =====
{{./pasted_image012.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image012.png)filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。

注意： filter() 不会对空数组进行检测。

注意： filter() 不会改变原始数组。
{{./pasted_image011.png}}

{{./pasted_image013.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image011.png)

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image013.png)

===== 8. =====
{{./pasted_image014.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image014.png)

IEEE 754标准中的浮点数并不能精确地表达小数

===== 9. =====
{{./pasted_image015.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image015.png)switch判断的是全等（===），new String(x)是个对象

{{./pasted_image016.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image016.png)// String.prototype 实例的原型指向构造函数的原型对象

===== 10 =====
{{./pasted_image017.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image017.png)

{{./pasted_image018.png}}![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image018.png)


a2是基本类型的值，逻辑上不应该有原型和方法。为了便于操作，有一种特殊的引用类型（基本包装类型）String。其实读取时，后台会自动完成下面的操作：
	  var str = new String("A"); //创建实例
	  str.__proto__;             //调用指定属性和方法
	  str = null;                //销毁实例
	  所以 a.__proto__ === a2.__proto__
	  但注意基本包装类型特殊就在于它对象（str）的生命周期，只存在于一行代码(a1.__proto__ === a2.__proto__)的执行瞬间。
	  这也就解释了为啥字符串也能操作属性和方法但不能添加。基本包装类型有三个（String,Number,Boolean）
	 （详情请看《js高程》 5.6基本包类型 P119）

===== 11 =====
{{./pasted_image019.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image019.png)%如果不是数值会调用Number（）去转化
	 '13' % 2       // 1
	  Infinity % 2  //NaN  Infinity 是无穷大
	  -9 % 2        // -1
巩固： 9 % -2        // 1   余数的正负号随第一个操作数

===== 13 =====
Array.isArray() 用于确定传递的值是否是一个 Array。

{{./pasted_image020.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image020.png)

Array.prototype是一个数组
	 数组的原型是数组，对象的原型是对象，函数的原型是函数

===== 14 =====
{{./pasted_image021.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image021.png)

[0]的boolean值是true
巩固：a[0] 的boolean是 false

===== 15.[]==[] =====

{{./pasted_image022.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image022.png)

两个引用类型， ==比较的是引用地址
巩固：[]== ![] 
	 (1)! 的优先级高于== ，右边运算结果等于 false
	 (2)一个引用类型和一个值去比较 把引用类型转化成值类型，左边0
	 (3)所以 0 == false  答案是true

===== 16 =====
{{./pasted_image023.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image023.png)

加号有拼接功能，减号就是逻辑运算
巩固：typeof (+"1")   // "number" 对非数值+—常被用来做类型转换相当于Number()

===== 17 =====
{{./pasted_image024.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image024.png)

+-又是一元加和减操作符号，就是数学里的正负号。负负得正哈。 
巩固： 一元运算符还有一个常用的用法就是将自执行函数的function从函数声明变成表达式。
	  常用的有 + - ～ ！ void
	  + function () { }
	  - function () { }
	  ~ function () { }
	  void function () { }

===== 18 =====
{{./pasted_image025.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image025.png)

如果没有值，map会跳过不会执行回调函数

===== 19 =====

{{./pasted_image026.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image026.png)

arguments会和函数参数绑定。
巩固：但如果es6付给初始值则无法修改
	  function sidEffecting(ary) {
		ary[0] = ary[2];
	  }
	  function bar(a=1,b,c) {
		c = 10
		sidEffecting(arguments);
		return a + b + c;
	}
	   bar(1,1,1)
	   //12
{{./pasted_image027.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image027.png)应该是参数是一个作用域, 括号里面又是一个

===== 20 =====
{{./pasted_image028.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image028.png)在JavaScript中number类型在JavaScript中以64位（8byte）来存储。这64位中有符号位1位、指数位11位、实数位52位。2的53次方时，是最大值。其值为：9007199254740992（0x20000000000000）。超过这个值的话，运算的结果就会不对.

===== 21. reverse =====

reverse() 方法用于颠倒数组中元素的顺序。
该方法会改变原来的数组，而不会创建新的数组。
[].reverse将返回this，当没有明确的接收器对象调用时，它将默认为默认的thisAKAwindow

===== 22.Number.MIN_VALUE > 0 =====
MIN_VALUE 属性是 JavaScript 中可表示的最小的数（接近 0 ，但不是负数）。它的近似值为 5 x 10-324。
MAX_VALUE 属性是 JavaScript 中可表示的最大的数。它的近似值为 1.7976931348623157 x 10308。


===== 23.[1 < 2 < 3, 3 < 2 < 1] =====

1 < 2    =>  true;
	  true < 3 =>  1 < 3 => true;
      
	  3 < 2     => false;
	  false < 1 => 0 < 1 => true;


===== 24. 2 == [[[2]]] =====


值和引用类型去比较,把引用类型转话成值类型
	 [2]）//2
巩固：++[+[]]+[+[]] //"10"
	 （1）(++([+[]])) + [+[]]  //这步看不懂看4题下面的文章,就是运算符权重判断
	 （2）(++([0])) + [0]      // 16题中我们讲过+用来做类型转换Number([]) ===0
	 （3）+([] + 1) + [0]            //数组的第0项就是[],++代表自增+1
	   *******  注意这一步不是 (++[]) + [0] 这样是错误的   **********
	 （4）+([] + 1) + [0]           // 前面+将"1"转成数字1 后边，+是拼接 "0" 所以是字符串"10"
	 https://stackoverflow.com/questions/7202157/why-does-return-the-string-10/7202287#7202287

===== 25 =====
__3.toString()__
__3..toString()__
__3...toString()__

因为在 js 中 1.1, 1., .1 都是合法的数字. 那么在解析 3.toString 的时候这个 . 到底是属于这个数字还是函数调用呢? 只能是数字, 因为3.合法啊!

===== 26 =====
{{./pasted_image029.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image029.png)

y 被赋值成全局变量，等价于
	 y = 1 ;
	 var x = y;

===== 27 =====

__var a = /123/,__
__b = /123/;__
__a == b__
__a === b__

false, false
解析：正则是对象，引用类型，相等（==）和全等（===）都是比较引用地址

===== 28 =====
__var a = [1, 2, 3],__
__b = [1, 2, 3],__
__c = [1, 2, 4]__
__a ==  b__
__a === b__
__a >   c__
__a <   c__

false, false, false, true
解析：相等（==）和全等（===）还是比较引用地址
	 引用类型间比较大小是按照字典序比较，就是先比第一项谁大，相同再去比第二项。

===== 29 =====
{{./pasted_image030.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image031.png)

Object 的实例是 a，a上并没有prototype属性
	 a的__poroto__ 指向的是Object.prototype，也就是Object.getPrototypeOf(a)。a的原型对象是b

===== 30 =====
__function f() {}__
__var a = f.prototype, b = Object.getPrototypeOf(f);__
__a === b__        

false
解析：a是构造函数f的原型 ： {constructor: ƒ}
	 b是实例f的原型对象 ： ƒ () { [native code] }

===== 32."1 2 3".replace(/\d/g, parseInt) =====

"1 NaN 3"
解析：replace() 回调函数的四个参数:
	  1、匹配项  
	  2、与模式中的子表达式匹配的字符串  
	  3、出现的位置  
	  4、stringObject 本身 。
如果没有与子表达式匹配的项，第二参数为出现的位置.所以第一个参数是匹配项，第二个参数是位置
 parseInt('1', 0)
 parseInt('2', 2)  //2进制中不可能有2
 parseInt('3', 4)


   "And the %1".replace(/%([1-8])/g,function(match,a , b ,d){
	  console.log(match +"  "+ a + " "+ b +" "+d )
	});
   //%1  1 8 And the %1 

===== 33 =====
__function f() {}__
__var parent = Object.getPrototypeOf(f);__
__f.name // ?__
__parent.name // ?__
__typeof eval(f.name) // ?__
__typeof eval(parent.name) //  ?__  

{{./pasted_image031.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image031.png)解析：f的函数名就是f
	 parent是f原型对象的名字为"" ,
	 先计算eval(f.name) 为 f,f的数据类型是function
	 eval(parent.name) 为undefined, "undefined"


===== 34 =====

__var lowerCaseOnly =  /^[a-z]+$/;__
__lowerCaseOnly.test(null), lowerCaseOnly.test()]__

：这里 test 函数会将参数转为字符串. 'nul', 'undefined' 自然都是全小写了

===== 35.[,,,].join(",") =====
{{./pasted_image032.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image032.png)join() 方法用于把数组中的所有元素放入一个字符串。

元素是通过指定的分隔符进行分隔的。
返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入 separator 字符串而生成的。
,,"
解析：因为javascript 在定义数组的时候允许最后一个元素后跟一个,
	 所以这个数组长度是3，
巩固： [,,1,].join(".").length //  3 {{./pasted_image033.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image033.png)

===== 36 =====
{{./pasted_image034.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image034.png)

这取决于浏览器。类是一个保留字，但是它被Chrome、Firefox和Opera接受为属性名。在另一方面，每个人都会接受大多数其他保留词（int，私有，抛出等）作为变量名，而类是VordBoint。

===== 37.var a = new Date("epoch") =====
{{./pasted_image035.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image035.png)您得到“无效日期”，这是一个实际的日期对象（一个日期的日期为true）。但无效。这是因为时间内部保持为一个数字，在这种情况下，它是NA。
	  在chrome上是undefined 
	  正确的是格式是var d = new Date(year, month, day, hours, minutes, seconds, milliseconds);

===== 38 =====

{{./pasted_image036.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image036.png)

false
解析：首先new在函数带（）时运算优先级和.一样所以从左向右执行
	 new Function() 的函数长度为0
巩固：function fn () {
		 var a = 1;
	  }
	  console.log(fn.length) 
	  //0 fn和new Function()一样

===== 39 =====
{{./pasted_image037.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image037.png)__var a = Date(0);__
__var b = new Date(0);__
__var c = new Date();__
__[a === b, b === c, a === c]__
[false, false, false]
解析：当日期被作为构造函数调用时，它返回一个相对于划时代的对象（JAN 01 1970）。当参数丢失时，它返回当前日期。当它作为函数调用时，它返回当前时间的字符串表示形式。
a是字符串   a === b // 数据类型都不同，肯定是false
b是对象     b === c // 引用类型，比的是引用地址
c也是对象   a === c // 数据类型都不同，肯定是false
巩固：  var a = Date(2018);
	   var b = Date(2001);
	   [a ===b ]
	   //[true] Date() 方法获得当日的日期,作为函数调用不需要，返回的同一个字符串
	   "Tue Jun 12 2018 14:36:24 GMT+0800 (CST)" 当然如果a,b执行时间相差1秒则为false

{{./pasted_image038.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image038.png)


===== 40. =====
__var min = Math.min(), max = Math.max()__
__min < max__
false
解析： Math.min 不传参数返回 Infinity, Math.max 不传参数返回 -Infinity 
	  无限集合之间不能比较大小。
巩固：Number.MAX_VALUE  > Number.MIN_VALUE  //true


===== 41 =====

__function captureOne(re, str) {__
__  var match = re.exec(str);__
__  return match && match[1];__
__}__
__var numRe  = /num=(\d+)/ig,__
__    wordRe = /word=(\w+)/i,__
__    a1 = captureOne(numRe,  "num=1"),__
__    a2 = captureOne(wordRe, "word=1"),__
__    a3 = captureOne(numRe,  "NUM=2"),__
__    a4 = captureOne(wordRe,  "WORD=2");__
__[a1 === a2, a3 === a4]__
{{./pasted_image039.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image039.png)

[true, false]
解析： ／g有一个属性叫lastIndex，每次匹配如果没有匹配到，它将重置为0，如果匹配到了，他将记录匹配的位置。我们看一个简单的例子吧。
		var numRe  = /num=(\d)/g;
		 numRe.test("num=1abcwewe") //true
		 numRe.lastIndex            //5     匹配到num=1后在5的索引位置
		 numRe.exec("num=1")        //fales 这次要从5的索引位置，开始匹配
		 numRe.lastIndex            //0     上一次匹配失败了numRe.lastIndex重制为0

===== 42 =====

__var a = new Date("2014-03-19"),__
__b = new Date(2014, 03, 19);__
__[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]__

[false, false]
解析： var a = new Date("2014-03-19")    //能够识别这样的字符串，返回想要的日期
	  Wed Mar 19 2014 08:00:00 GMT+0800 (CST)
	  b = new Date(2014, 03, 19);       //参数要按照索引来
	  Sat Apr 19 2014 00:00:00 GMT+0800 (CST)
	  月是从0索引，日期是从1 
	  getDay()是获取星期几
	  getMonth()是获取月份所以都不同
巩固： [a.getDate() === b.getDate()] //true



===== 43 =====

 __if ('http://giftwrapped.com/picture.jpg'.match('.gif')) {__
__    'a gif file'__
__  } else {__
__    'not a gif file'__
__  }__

match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。

该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。

__stringObject.match(searchvalue)__
__stringObject.match(regexp)__
searchvalue	必需。规定要检索的字符串值。
regexp	必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。
**返回值**
存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。
**说明**
match() 方法将检索字符串 stringObject，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。

如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。index 属性声明的是匹配文本的起始字符在 stringObject 中的位置，input 属性声明的是对 stringObject 的引用。

如果 regexp 具有标志 g，则 match() 方法将执行全局检索，找到 stringObject 中的所有匹配子字符串。若没有找到任何匹配的子串，则返回 null。如果找到了一个或多个匹配子串，则返回一个数组。不过全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是 stringObject 中所有的匹配子串，而且也没有 index 属性或 input 属性。

注意：在全局检索模式下，match() 即不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的位置。如果您需要这些全局检索的信息，可以使用 RegExp.exec()。

'a gif file'
解析： String.prototype.match 接受一个正则, 如果不是, 按照 new RegExp(obj) 转化. 所以 . 并不会转义 。 那么 /gif 就匹配了 /.gif/
巩固： if ('http://giftwrapped.com/picture.jpg'.indexOf('.gif')) {
		'a gif file'
	  } else {
		'not a gif file'
	  }
	  //'a gif file' 同样的道理

{{./pasted_image040.png}}

![](/media/nvnvyezi/linux_software/linux-web/web-note/js基础/pasted_image040.png)

